// #![warn(missing_docs)]

//! Skylight Polarization Utilities

pub mod camera;
pub mod error;
pub mod estimator;
pub mod image;
pub mod iter;
pub mod light;
pub mod model;
pub mod state;

pub mod prelude {
    pub use crate::camera::{Camera, Lens};
    pub use crate::error::Error;
    pub use crate::model::SkyModel;
    // pub use crate::estimator::pattern_match::{PatternMatch, StochasticSearch};
    pub use crate::image::IntensityImage;
    pub use crate::iter::RayIterator;
    pub use crate::light::{
        aop::Aop,
        dop::Dop,
        ray::{GlobalFrame, Ray, RayLocation, RaySensor, SensorFrame},
    };
    pub use crate::state::{Orientation, Position};
    pub use crate::{CameraEnu, CameraFrd};
}

use sguaba::system;

/// A coordinate system with its origin at the optical center of a camera and
/// its X, Y, Z axes along East, North, and Up, respectively.
system!(pub struct CameraEnu using ENU);

/// A coordinate system with its origin at the optical center of a camera and
/// its X, Y, Z axes pointing forward in the direction of travel, right of the
/// optical center, and down into lens through the sensor plane, respectively.
system!(pub struct CameraFrd using FRD);

/*
#[cfg(test)]
mod tests {
    use crate::prelude::*;
    use chrono::prelude::*;
    use nalgebra::{Rotation3, Vector2};

    /// Regression test simulation algorithm.
    /// Using ground truth generated by commit with hash 4019279...
    #[test]
    fn regress_simulate() {
        let sensor = RaySensor::default();

        let rays = vec![
            Ray::<GlobalFrame>::new(
                RayLocation::at_pixel((0, 0), &sensor),
                Aop::from_deg(-37.420423616444666),
                Dop::new(0.0),
            ),
            Ray::<GlobalFrame>::new(
                RayLocation::at_pixel((2448, 0), &sensor),
                Aop::from_deg(-77.361022793184380),
                Dop::new(0.0),
            ),
            Ray::<GlobalFrame>::new(
                RayLocation::at_pixel((0, 2048), &sensor),
                Aop::from_deg(40.030473803771110),
                Dop::new(0.0),
            ),
            Ray::<GlobalFrame>::new(
                RayLocation::at_pixel((2448, 2048), &sensor),
                Aop::from_deg(62.284743078589490),
                Dop::new(0.0),
            ),
        ];

        let model = RayleighModel::new(
            Position {
                lat: 44.2187,
                lon: -76.4747,
            },
            "2025-06-13T16:26:47+00:00"
                .parse::<DateTime<Utc>>()
                .unwrap(),
        );

        let cam = Camera::new(
            Lens::new(8.0).expect("focal_length is greater than 0.0"),
            sguaba::Orientation::<CameraEnu>::default(),
        );

        for ray in rays {
            assert_eq!(ray, cam.simulate_ray(ray.loc().clone(), &model));
        }
    }
}
*/
